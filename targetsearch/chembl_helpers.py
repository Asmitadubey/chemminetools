import psycopg2
import psycopg2.sql as sql
import requests
from psycopg2.extras import NamedTupleCursor

class OutputColumn:
    def __init__(self, sql, desc, visible=False, name=None):
        """Initialize an output column data structure in various ways.
        
        OutputColumn(sql, desc):
            Define an output column given a simple SQL SELECT expression
            fragment (usually the FQN). The display name will be generated by
            replacing the field separator '.' with a double-underscore '__'.
            
        OutputColumn(sql, desc, name=NAME):
            Define an output column given a custom SQL SELECT expression
            fragment and override the display name.
        
        Arguments:
        sql -- A string containing an SQL SELECT expression fragment.
        desc -- A string description for the column.
        visible -- Boolean for whether to display this column by default.
        name -- A string with the display name used in the output table. Must
            be safe for use in Django and DataTables (i.e. no periods).
        """
        
        self.sql = sql
        self.desc = desc
        self.visible = visible
        if name is not None:
            self.name = name
        else:
            self.name = self.sql.replace('.', '__')
    
    def __str__(self):
        return self.sql + " AS " + self.name

def groupBy(keyFn, tuples):
    temp_dict = {}
    for t in tuples:
        key = keyFn(t)
        a = temp_dict.get(key,[])
        a.append(t)
        temp_dict[key] = a

    return temp_dict

def runQuery(query,values):
    conn = psycopg2.connect(host = "chembl.cycqd59qnrsj.us-east-2.rds.amazonaws.com",
            user="chembl",dbname="chembl",password="chembl1889")
    cur = conn.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)
    cur.execute(query,values)
    return cur.fetchall()

def runQuery2(query, values):
    dbhost = 'chembl.cycqd59qnrsj.us-east-2.rds.amazonaws.com'
    dbname = 'chembl_25'
    dbuser = 'chembl'
    dbpass = 'chembl1889'
    
    with psycopg2.connect(host=dbhost, dbname=dbname, user=dbuser, password=dbpass) as conn:
        cur = conn.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)
        cur.execute(query, values)
        return cur.fetchall()

def get_chembl_sdfs(chemblIds):
    data = runQuery("""
      SELECT chembl_id||molfile 
      FROM chembl_id_lookup JOIN
           compound_structures ON(entity_id=molregno)
      WHERE chembl_id_lookup.chembl_id IN %s""",(chemblIds,))
    return [row[0] for row in data]
def get_chembl_smiles(chemblIds):
    data = runQuery("""
      SELECT canonical_smiles||' '||chembl_id
      FROM chembl_id_lookup JOIN
           compound_structures ON(entity_id=molregno)
      WHERE chembl_id_lookup.chembl_id IN %s""",(chemblIds,))
    return [row[0] for row in data]
        
def byActivity(chemblIds=None,accessionIds=None):
    if chemblIds is not None and accessionIds is None:
        condition = "chembl_id_lookup.chembl_id in %s"
        ids = chemblIds
        groupByIndex = 0
    elif chemblIds is None and accessionIds is not None:
        condition = "chembl_id_lookup.entity_type='COMPOUND' AND accession in %s"
        ids = accessionIds
        groupByIndex = 1
    else:
        raise Exception("One of either 'chemblIds' or accessionIds' must be given")

    data = runQuery("""
            select distinct chembl_id_lookup.chembl_id, accession,
                    activities.molregno, pref_name, activity_id, assays.chembl_id AS chembl_assay_id, 
                    component_sequences.description, organism, 
                    activities.standard_value, activities.standard_units, 
                    activities.standard_flag, activities.standard_type
                from chembl_id_lookup
                        join activities on(entity_id = molregno)
                        join molecule_dictionary using(molregno)
                        join assays using(assay_id)
                        join target_components using(tid)
                        join component_sequences using(component_id)
                where """ + condition+
                "order by 1 ",
                (ids,))
    return groupBy(lambda t: t[groupByIndex], data)

def byAnnotations(chemblIds=None,accessionIds=None):
    if chemblIds is not None and accessionIds is None:
        condition = "chembl_id_lookup.chembl_id in %s"
        ids = chemblIds
        groupByIndex = 0
    elif chemblIds is None and accessionIds is not None:
        condition = "accession in %s"
        ids = accessionIds
        groupByIndex = 1
    else:
        raise Exception("One of either 'chemblIds' or accessionIds' must be given")


    data = runQuery("""
            select distinct chembl_id,  accession,
                    mechanism_of_action, tid,component_id, description, 
                    organism, string_agg(mesh_id||':'|| mesh_heading,',') as mesh_indication
                from chembl_id_lookup
                        join molecule_dictionary using(chembl_id)
                        join drug_mechanism using(molregno)
                        join target_components using(tid)
                        join component_sequences using(component_id)
                        left join drug_indication using(molregno)
                where """+condition+"""
                group by chembl_id,  accession,
                    mechanism_of_action, tid,component_id, description, 
                    organism
                order by 1
            """,(ids,))
    return groupBy(lambda t: t[groupByIndex], data)

class AnnotationSearch:
    """Class containing annotation search functions and related data"""
    
    # List of expected database output columns. Update as needed.
    # Should be a list of tuples containing:
    # (str sql, bool visible, str desc)
    # Last update: ChEMBLdb 25
    # NOTE that although OutputColumn expects this data in the order
    # (sql, desc, visible, name), here "visible" comes right after "sql" for
    # easier readability, since "desc" can get quite long.
    cols_fqn_list = [
        ('chembl_id_lookup.chembl_id', True, "ChEMBL identifier"),
        ('chembl_id_lookup.entity_type', False, "Type of entity (e.g., COMPOUND, ASSAY, TARGET)"),
        ('chembl_id_lookup.entity_id', False, "Primary key for that entity in corresponding table (e.g., molregno for compounds, tid for targets)"),
        ('chembl_id_lookup.status', False, "Indicates whether the status of the entity within the database - ACTIVE, INACTIVE (downgraded), OBS (obsolete/removed)."),
        ('molecule_dictionary.molregno', False, "Internal Primary Key for the molecule"),
        ('molecule_dictionary.pref_name', False, "Preferred name for the molecule"),
        ('molecule_dictionary.max_phase', False, "Maximum phase of development reached for the compound (4 = approved). Null where max phase has not yet been assigned."),
        ('molecule_dictionary.therapeutic_flag', False, "Indicates that a drug has a therapeutic application (as opposed to e.g., an imaging agent, additive etc)."),
        ('molecule_dictionary.dosed_ingredient', False, "Indicates that the drug is dosed in this form (e.g., a particular salt)"),
        ('molecule_dictionary.structure_type', False, "Indications whether the molecule has a small molecule structure or a protein sequence (MOL indicates an entry in the compound_structures table, SEQ indications an entry in the protein_therapeutics table, NONE indicates an entry in neither table, e.g., structure unknown)"),
        ('molecule_dictionary.chebi_par_id', False, "Preferred ChEBI ID for the compound (where different from assigned)"),
        ('molecule_dictionary.molecule_type', False, "Type of molecule (Small molecule, Protein, Antibody, Oligosaccharide, Oligonucleotide, Cell, Unknown)"),
        ('molecule_dictionary.first_approval', False, "Earliest known approval year for the molecule"),
        ('molecule_dictionary.oral', False, "Indicates whether the drug is known to be administered orally."),
        ('molecule_dictionary.parenteral', False, "Indicates whether the drug is known to be administered parenterally"),
        ('molecule_dictionary.topical', False, "Indicates whether the drug is known to be administered topically."),
        ('molecule_dictionary.black_box_warning', False, "Indicates that the drug has a black box warning"),
        ('molecule_dictionary.natural_product', False, "Indicates whether the compound is natural product-derived (currently curated only for drugs)"),
        ('molecule_dictionary.first_in_class', False, "Indicates whether this is known to be the first compound of its class (e.g., acting on a particular target)."),
        ('molecule_dictionary.chirality', False, "Shows whether a drug is dosed as a racemic mixture (0), single stereoisomer (1) or is an achiral molecule (2)"),
        ('molecule_dictionary.prodrug', False, "Indicates that the molecule is a pro-drug (see molecule hierarchy for active component, where known)"),
        ('molecule_dictionary.inorganic_flag', False, "Indicates whether the molecule is inorganic (i.e., containing only metal atoms and <2 carbon atoms)"),
        ('molecule_dictionary.usan_year', False, "The year in which the application for a USAN/INN name was made"),
        ('molecule_dictionary.availability_type', False, "The availability type for the drug (0 = discontinued, 1 = prescription only, 2 = over the counter)"),
        ('molecule_dictionary.usan_stem', False, "Where the compound has been assigned a USAN name, this indicates the stem, as described in the USAN_STEM table."),
        ('molecule_dictionary.polymer_flag', False, "Indicates whether a molecule is a small molecule polymer (e.g., polistyrex)"),
        ('molecule_dictionary.usan_substem', False, "Where the compound has been assigned a USAN name, this indicates the substem"),
        ('molecule_dictionary.usan_stem_definition', False, "Definition of the USAN stem"),
        ('molecule_dictionary.indication_class', False, "Indication class(es) assigned to a drug in the USP dictionary"),
        ('molecule_dictionary.withdrawn_flag', False, "Flag indicating whether the drug has been withdrawn in at least one country (not necessarily in the US)"),
        ('molecule_dictionary.withdrawn_year', False, "Year the drug was first withdrawn in any country"),
        ('molecule_dictionary.withdrawn_country', False, "List of countries/regions where the drug has been withdrawn"),
        ('molecule_dictionary.withdrawn_reason', False, "Reasons for withdrawl (e.g., safety)"),
        ('molecule_dictionary.withdrawn_class', False, "High level categories for the withdrawn reason (e.g., Cardiotoxicity, Hepatotoxicity)"),
        ('drug_mechanism.mec_id', False, "Primary key for each drug mechanism of action"),
        ('drug_mechanism.record_id', False, "Record_id for the drug (foreign key to compound_records table)"),
        ('drug_mechanism.mechanism_of_action', True, "Description of the mechanism of action e.g., 'Phosphodiesterase 5 inhibitor'"),
        ('drug_mechanism.tid', True, "Target associated with this mechanism of action (foreign key to target_dictionary table)"),
        ('drug_mechanism.site_id', False, "Binding site for the drug within the target (where known) - foreign key to binding_sites table"),
        ('drug_mechanism.action_type', False, "Type of action of the drug on the target e.g., agonist/antagonist etc (foreign key to action_type table)"),
        ('drug_mechanism.direct_interaction', False, "Flag to show whether the molecule is believed to interact directly with the target (1 = yes, 0 = no)"),
        ('drug_mechanism.molecular_mechanism', False, "Flag to show whether the mechanism of action describes the molecular target of the drug, rather than a higher-level physiological mechanism e.g., vasodilator (1 = yes, 0 = no)"),
        ('drug_mechanism.disease_efficacy', False, "Flag to show whether the target assigned is believed to play a role in the efficacy of the drug in the indication(s) for which it is approved (1 = yes, 0 = no)"),
        ('drug_mechanism.mechanism_comment', False, "Additional comments regarding the mechanism of action"),
        ('drug_mechanism.selectivity_comment', False, "Additional comments regarding the selectivity of the drug"),
        ('drug_mechanism.binding_site_comment', False, "Additional comments regarding the binding site of the drug"),
        ('component_sequences.component_id', True, "Primary key. Unique identifier for the component."),
        ('target_components.targcomp_id', False, "Primary key."),
        ('target_components.homologue', False, "Indicates that the given component is a homologue of the correct component (e.g., from a different species) when set to 1. This may be the case if the sequence for the correct protein/nucleic acid cannot be found in sequence databases. A value of 2 indicates that the sequence given is a representative of a species group, e.g., an E. coli protein to represent the target of a broad-spectrum antibiotic."),
        ('component_sequences.component_type', False, "Type of molecular component represented (e.g., 'PROTEIN','DNA','RNA')."),
        ('component_sequences.accession', True, "Accession for the sequence in the source database from which it was taken (e.g., UniProt accession for proteins)."),
        ('component_sequences.sequence', False, "A representative sequence for the molecular component, as given in the source sequence database (not necessarily the exact sequence used in the assay)."),
        ('component_sequences.sequence_md5sum', False, "MD5 checksum of the sequence."),
        ('component_sequences.description', True, "Description/name for the molecular component, usually taken from the source sequence database."),
        ('component_sequences.tax_id', False, "NCBI tax ID for the sequence in the source database (i.e., species that the protein/nucleic acid sequence comes from)."),
        ('component_sequences.organism', True, "Name of the organism the sequence comes from."),
        ('component_sequences.db_source', False, "The name of the source sequence database from which sequences/accessions are taken. For UniProt proteins, this field indicates whether the sequence is from SWISS-PROT or TREMBL."),
        ('component_sequences.db_version', False, "The version of the source sequence database from which sequences/accession were last updated."),
        ('drug_indication.drugind_id', False, "Primary key"),
        ('drug_indication.record_id', False, "Foreign key to compound_records table. Links to the drug record to which this indication applies"),
        ('drug_indication.max_phase_for_ind', False, "The maximum phase of development that the drug is known to have reached for this particular indication"),
        ('drug_indication.mesh_id', True, "Medical Subject Headings (MeSH) disease identifier corresponding to the indication"),
        ('drug_indication.mesh_heading', True, "Medical Subject Heading term for the MeSH disease ID"),
        ('drug_indication.efo_id', False, "Experimental Factor Ontology (EFO) disease identifier corresponding to the indication"),
        ('drug_indication.efo_term', False, "Experimental Factor Ontology term for the EFO ID"),
        ]
    
    # List of OutputColumn objects
    sql_cols_list = [ OutputColumn(sql, desc, visible) for sql, visible, desc in cols_fqn_list ]

    # Add any custom SELECT fragments here
    # e.g. string_agg(mesh_id||':'||mesh_heading,',') AS mesh_indication :
    sql_cols_list.append(OutputColumn("string_agg(mesh_id||':'||mesh_heading,',')",
                                      "Aggregated list of MeSH identifiers and heading terms.",
                                      visible=True, name='mesh_indication'))

    # List of GROUP BY fields. For string_agg.
    sql_group_list = [
        'chembl_id_lookup.chembl_id',
        'component_sequences.accession',
        'drug_mechanism.mechanism_of_action',
        'drug_mechanism.tid',
        'component_sequences.component_id',
        'component_sequences.description',
        'component_sequences.organism',
        'molecule_dictionary.molregno',
        'drug_mechanism.mec_id',
        'target_components.targcomp_id',
        'drug_indication.drugind_id',
        ]
    if len(sql_group_list) == 0:
        sql_group_str = ''
    else:
        sql_group_str = 'GROUP BY ' + ', '.join(sql_group_list)
    
    def search(id_type, ids):
        """Search for targets by annotations, returning all database columns.
        
        By returning all columns, we allow the user to decide which columns are
        desired, by means of the Django/DataTables interface.
        
        Do note that the argument style is different than byAnnotations().
        
        Arguments:
        id_type -- String describing type of ID. Must be one of:
                'chembl', 'accession'
        ids -- Python list of IDs to query
        """
        
        # Adjust query condition based on ID type
        if id_type == 'chembl':
            condition = 'chembl_id_lookup.chembl_id = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('chembl_id_lookup.chembl_id')
            groupByIndex = 'chembl_id_lookup__chembl_id'
        elif id_type == 'accession':
            condition = 'component_sequences.accession = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('component_sequences.accession')
            groupByIndex = 'component_sequences__accession'
        else:
            raise Exception("id_type should be either 'chembl' or 'accession'")
        
        query = sql.SQL("""SELECT DISTINCT {cols} FROM chembl_id_lookup
                        JOIN molecule_dictionary USING(chembl_id)
                        JOIN drug_mechanism USING(molregno)
                        JOIN target_components USING(tid)
                        JOIN component_sequences USING(component_id)
                        LEFT JOIN drug_indication USING(molregno)
                        WHERE {condition}
                        {group}
                        ORDER BY 1""")\
                .format(cols=sql.SQL(', ').join(sql.SQL(str(c)) for c in AnnotationSearch.sql_cols_list),
                        condition=sql.SQL(condition),
                        group=sql.SQL(AnnotationSearch.sql_group_str))
        
        data = runQuery2(query, (ids,))
        data = [ d._asdict() for d in data ]
        #return groupBy(lambda t: t[groupByIndex], data)
        return data

class ActivitySearch:
    """Class containing activity search functions and related data"""
    
    # List of expected database output columns. Update as needed.
    # Last update: ChEMBLdb 25
    cols_fqn_list = [
        ('chembl_id_lookup.chembl_id', True, ""),
        ('chembl_id_lookup.entity_type', False, ""),
        ('chembl_id_lookup.entity_id', False, ""),
        ('chembl_id_lookup.status', False, ""),
        ('activities.activity_id', True, ""),
        ('activities.doc_id', False, ""),
        ('activities.record_id', False, ""),
        ('activities.standard_relation', False, ""),
        ('activities.standard_value', True, ""),
        ('activities.standard_units', True, ""),
        ('activities.standard_flag', True, ""),
        ('activities.standard_type', True, ""),
        ('activities.activity_comment', False, ""),
        ('activities.data_validity_comment', False, ""),
        ('activities.potential_duplicate', False, ""),
        ('activities.pchembl_value', False, ""),
        ('activities.bao_endpoint', False, ""),
        ('activities.uo_units', False, ""),
        ('activities.qudt_units', False, ""),
        ('activities.toid', False, ""),
        ('activities.upper_value', False, ""),
        ('activities.standard_upper_value', False, ""),
        ('activities.src_id', False, ""),
        ('activities.type', False, ""),
        ('activities.relation', False, ""),
        ('activities.value', False, ""),
        ('activities.units', False, ""),
        ('activities.text_value', False, ""),
        ('activities.standard_text_value', False, ""),
        ('molecule_dictionary.molregno', True, ""),
        ('molecule_dictionary.pref_name', True, ""),
        ('molecule_dictionary.chembl_id', False, ""),
        ('molecule_dictionary.max_phase', False, ""),
        ('molecule_dictionary.therapeutic_flag', False, ""),
        ('molecule_dictionary.dosed_ingredient', False, ""),
        ('molecule_dictionary.structure_type', False, ""),
        ('molecule_dictionary.chebi_par_id', False, ""),
        ('molecule_dictionary.molecule_type', False, ""),
        ('molecule_dictionary.first_approval', False, ""),
        ('molecule_dictionary.oral', False, ""),
        ('molecule_dictionary.parenteral', False, ""),
        ('molecule_dictionary.topical', False, ""),
        ('molecule_dictionary.black_box_warning', False, ""),
        ('molecule_dictionary.natural_product', False, ""),
        ('molecule_dictionary.first_in_class', False, ""),
        ('molecule_dictionary.chirality', False, ""),
        ('molecule_dictionary.prodrug', False, ""),
        ('molecule_dictionary.inorganic_flag', False, ""),
        ('molecule_dictionary.usan_year', False, ""),
        ('molecule_dictionary.availability_type', False, ""),
        ('molecule_dictionary.usan_stem', False, ""),
        ('molecule_dictionary.polymer_flag', False, ""),
        ('molecule_dictionary.usan_substem', False, ""),
        ('molecule_dictionary.usan_stem_definition', False, ""),
        ('molecule_dictionary.indication_class', False, ""),
        ('molecule_dictionary.withdrawn_flag', False, ""),
        ('molecule_dictionary.withdrawn_year', False, ""),
        ('molecule_dictionary.withdrawn_country', False, ""),
        ('molecule_dictionary.withdrawn_reason', False, ""),
        ('molecule_dictionary.withdrawn_class', False, ""),
        ('assays.assay_id', False, ""),
        ('assays.doc_id', False, ""),
        ('assays.description', False, ""),
        ('assays.assay_type', False, ""),
        ('assays.assay_test_type', False, ""),
        ('assays.assay_category', False, ""),
        ('assays.assay_organism', False, ""),
        ('assays.assay_tax_id', False, ""),
        ('assays.assay_strain', False, ""),
        ('assays.assay_tissue', False, ""),
        ('assays.assay_cell_type', False, ""),
        ('assays.assay_subcellular_fraction', False, ""),
        ('assays.tid', False, ""),
        ('assays.relationship_type', False, ""),
        ('assays.confidence_score', False, ""),
        ('assays.curated_by', False, ""),
        ('assays.src_id', False, ""),
        ('assays.src_assay_id', False, ""),
        ('assays.chembl_id', True, ""),
        ('assays.cell_id', False, ""),
        ('assays.bao_format', False, ""),
        ('assays.tissue_id', False, ""),
        ('assays.variant_id', False, ""),
        ('assays.aidx', False, ""),
        ('target_components.targcomp_id', False, ""),
        ('target_components.homologue', False, ""),
        ('component_sequences.component_id', False, ""),
        ('component_sequences.component_type', False, ""),
        ('component_sequences.accession', True, ""),
        ('component_sequences.sequence', False, ""),
        ('component_sequences.sequence_md5sum', False, ""),
        ('component_sequences.description', True, ""),
        ('component_sequences.tax_id', False, ""),
        ('component_sequences.organism', True, ""),
        ('component_sequences.db_source', False, ""),
        ('component_sequences.db_version', False, ""),
        ]
    
    # List of OutputColumn objects
    sql_cols_list = [ OutputColumn(sql, desc, visible) for sql, visible, desc in cols_fqn_list ]
    
    def search(id_type, ids):
        """Search for targets by activity, returning all database columns.
        
        By returning all columns, we allow the user to decide which columns are
        desired, by means of the Django/DataTables interface.
        
        Do note that the argument style is different than byActivity().
        
        Arguments:
        id_type -- String describing type of ID. Must be one of:
                'chembl', 'accession'
        ids -- Python list of IDs to query
        """
        
        # Adjust query condition based on ID type
        if id_type == 'chembl':
            condition = 'chembl_id_lookup.chembl_id = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('chembl_id_lookup.chembl_id')
            groupByIndex = 'chembl_id_lookup__chembl_id'
        elif id_type == 'accession':
            condition = "chembl_id_lookup.entity_type='COMPOUND' AND component_sequences.accession = ANY(%s)"
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('component_sequences.accession')
            groupByIndex = 'component_sequences__accession'
        else:
            raise Exception("id_type should be either 'chembl' or 'accession'")
        
        query = sql.SQL("""SELECT {cols} FROM chembl_id_lookup
                        JOIN activities ON(entity_id = molregno)
                        JOIN molecule_dictionary USING(molregno)
                        JOIN assays USING(assay_id)
                        JOIN target_components USING(tid)
                        JOIN component_sequences USING(component_id)
                        WHERE {condition}
                        ORDER BY 1""")\
                .format(cols=sql.SQL(', ').join(sql.SQL(str(c)) for c in ActivitySearch.sql_cols_list),
                        condition=sql.SQL(condition))
        
        data = runQuery2(query, (ids,))
        data = [ d._asdict() for d in data ]
        #return groupBy(lambda t: t[groupByIndex], data)
        return data

def mapToChembl(unknownIds, sourceId):
    chemblIds = set()
    for unknownId in unknownIds:
        req = requests.get("https://www.ebi.ac.uk/unichem/rest/src_compound_id/"+unknownId+"/"+str(sourceId)+"/1")
        #print("\n\nreq.json: "+str(req.json()))
        result = req.json()
        #print("got result: "+str(result))
        if "error" in result: 
            raise Exception(result["error"])
        if isinstance(result,list) and len(result) > 0 and ("src_compound_id" in result[0]) :
            chemblIds.add(result[0]["src_compound_id"])

    #print("final chembl ids: "+str(chemblIds))

    return tuple(chemblIds)

def getUniChemSources():
    sources = {}
    sourceReq = requests.get("https://www.ebi.ac.uk/unichem/rest/src_ids/")
    sourceIds = [ source["src_id"] for source in sourceReq.json()]

    for sourceId in sourceIds:
        infoReq = requests.get(" https://www.ebi.ac.uk/unichem/rest/sources/"+sourceId)
        data = infoReq.json()[0]
        #print(str(data["src_id"])+"\t"+data["name_label"])
        sources[data["src_id"]] = data["name_label"]

    return sources;


#getUniChemSources()
#mapToChembl(['DB00829','DB00945'],2)

#print(chemblTargetAccessionsByActivity(('CHEMBL26',)))
#print(chemblTargetAccessionsByAnnotations(('CHEMBL25',)))
