import psycopg2
import psycopg2.sql as sql
import requests
import json
import os
from psycopg2.extras import NamedTupleCursor
from django.conf import settings

class OutputColumn:
    def __init__(self, sql, desc, visible=False, name=None):
        """Initialize an output column data structure in various ways.
        
        OutputColumn(sql, desc):
            Define an output column given a simple SQL SELECT expression
            fragment (usually the FQN). The display name will be generated by
            replacing the field separator '.' with a double-underscore '__'.
            
        OutputColumn(sql, desc, name=NAME):
            Define an output column given a custom SQL SELECT expression
            fragment and override the display name.
        
        Arguments:
        sql -- A string containing an SQL SELECT expression fragment.
        desc -- A string description for the column.
        visible -- Boolean for whether to display this column by default.
        name -- A string with the display name used in the output table. Must
            be safe for use in Django and DataTables (i.e. no periods).
        """
        
        self.sql = sql
        self.desc = desc
        self.visible = visible
        if name is not None:
            self.name = name
        else:
            self.name = self.sql.replace('.', '__')
    
    def __str__(self):
        return self.sql + " AS " + self.name

def groupBy(keyFn, tuples):
    temp_dict = {}
    for t in tuples:
        key = keyFn(t)
        a = temp_dict.get(key,[])
        a.append(t)
        temp_dict[key] = a

    return temp_dict

def runQuery(query,values):
    conn = psycopg2.connect(host = "chembl.cycqd59qnrsj.us-east-2.rds.amazonaws.com",
            user="chembl",dbname="chembl",password="chembl1889")
    cur = conn.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)
    cur.execute(query,values)
    return cur.fetchall()

def runQuery2(query, values):
    dbhost = 'chembl.cycqd59qnrsj.us-east-2.rds.amazonaws.com'
    dbname = 'chembl_25'
    dbuser = 'chembl'
    dbpass = 'chembl1889'
    
    with psycopg2.connect(host=dbhost, dbname=dbname, user=dbuser, password=dbpass) as conn:
        cur = conn.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)
        cur.execute(query, values)
        return cur.fetchall()

def get_chembl_sdfs(chemblIds):
    data = runQuery("""
      SELECT chembl_id||molfile 
      FROM chembl_id_lookup JOIN
           compound_structures ON(entity_id=molregno)
      WHERE chembl_id_lookup.chembl_id IN %s""",(chemblIds,))
    return [row[0] for row in data]
def get_chembl_smiles(chemblIds):
    data = runQuery("""
      SELECT canonical_smiles||' '||chembl_id
      FROM chembl_id_lookup JOIN
           compound_structures ON(entity_id=molregno)
      WHERE chembl_id_lookup.chembl_id IN %s""",(chemblIds,))
    return [row[0] for row in data]
        
def byActivity(chemblIds=None,accessionIds=None):
    if chemblIds is not None and accessionIds is None:
        condition = "chembl_id_lookup.chembl_id in %s"
        ids = chemblIds
        groupByIndex = 0
    elif chemblIds is None and accessionIds is not None:
        condition = "chembl_id_lookup.entity_type='COMPOUND' AND accession in %s"
        ids = accessionIds
        groupByIndex = 1
    else:
        raise Exception("One of either 'chemblIds' or accessionIds' must be given")

    data = runQuery("""
            select distinct chembl_id_lookup.chembl_id, accession,
                    activities.molregno, pref_name, activity_id, assays.chembl_id AS chembl_assay_id, 
                    component_sequences.description, organism, 
                    activities.standard_value, activities.standard_units, 
                    activities.standard_flag, activities.standard_type
                from chembl_id_lookup
                        join activities on(entity_id = molregno)
                        join molecule_dictionary using(molregno)
                        join assays using(assay_id)
                        join target_components using(tid)
                        join component_sequences using(component_id)
                where """ + condition+
                "order by 1 ",
                (ids,))
    return groupBy(lambda t: t[groupByIndex], data)

def byAnnotations(chemblIds=None,accessionIds=None):
    if chemblIds is not None and accessionIds is None:
        condition = "chembl_id_lookup.chembl_id in %s"
        ids = chemblIds
        groupByIndex = 0
    elif chemblIds is None and accessionIds is not None:
        condition = "accession in %s"
        ids = accessionIds
        groupByIndex = 1
    else:
        raise Exception("One of either 'chemblIds' or accessionIds' must be given")


    data = runQuery("""
            select distinct chembl_id,  accession,
                    mechanism_of_action, tid,component_id, description, 
                    organism, string_agg(mesh_id||':'|| mesh_heading,',') as mesh_indication
                from chembl_id_lookup
                        join molecule_dictionary using(chembl_id)
                        join drug_mechanism using(molregno)
                        join target_components using(tid)
                        join component_sequences using(component_id)
                        left join drug_indication using(molregno)
                where """+condition+"""
                group by chembl_id,  accession,
                    mechanism_of_action, tid,component_id, description, 
                    organism
                order by 1
            """,(ids,))
    return groupBy(lambda t: t[groupByIndex], data)

class MeshIndicationSearch:
    """Class containing MeSH indication search functions and related data"""
    
    mesh_ind_sql = ['chembl_id_lookup.chembl_id',
                    'component_sequences.accession',
                    'drug_mechanism.mechanism_of_action',
                    'drug_mechanism.tid',
                    'component_sequences.component_id',
                    'component_sequences.description',
                    'component_sequences.organism',
                    ]
    
    mesh_ind_list = list()
    for m in mesh_ind_sql:
        m_id = m.replace('.', '__')
        m_sql = m
        mesh_ind_list.append({'id': m_id,
                              'sql': m_sql})
    
    mesh_ind_group_str = 'GROUP BY ' + ', '.join(mesh_ind_sql)
    
    def search(id_type, ids):
        """Search for MeSH indications. Basically the original limited-column search.
        
        The idea is to compare the limited columns from the original search with
        corresponding columns in the new AnnotationSearch, and add in the appropriate
        MeSH indication.
        
        Arguments:
        id_type -- String describing type of ID. Must be one of:
                'compound', 'target'
        ids -- Python list of IDs to query
        """
        
        # Adjust query condition based on ID type
        if id_type == 'compound':
            condition = 'chembl_id_lookup.chembl_id = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('chembl_id_lookup.chembl_id')
            #groupByIndex = 'chembl_id_lookup__chembl_id'
        elif id_type == 'target':
            condition = 'component_sequences.accession = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('component_sequences.accession')
            #groupByIndex = 'component_sequences__accession'
        else:
            raise Exception("MeshIndicationSearch: id_type should be either 'compound' or 'target'")
        
        query = sql.SQL("""SELECT DISTINCT {cols},
                        STRING_AGG(mesh_id||':'||mesh_heading,',') AS mesh_indication
                        FROM chembl_id_lookup
                        JOIN molecule_dictionary USING(chembl_id)
                        JOIN drug_mechanism USING(molregno)
                        JOIN target_components USING(tid)
                        JOIN component_sequences USING(component_id)
                        LEFT JOIN drug_indication USING(molregno)
                        WHERE {condition}
                        {group}
                        ORDER BY 1""")\
                    .format(cols=sql.SQL(', ').join(sql.SQL("{} AS {}".format(c['sql'], c['id'])) for c in MeshIndicationSearch.mesh_ind_list),
                    condition=sql.SQL(condition),
                    group=sql.SQL(MeshIndicationSearch.mesh_ind_group_str))
        
        data = runQuery2(query, (ids,))
        data = [ d._asdict() for d in data ]
        #return groupBy(lambda t: t[groupByIndex], data)
        return data

class AnnotationSearch:
    """Class containing annotation search functions and related data"""
    
    with open(os.path.join(settings.PROJECT_DIR, 'targetsearch/annotation_list.json')) as f:
        annotation_list = json.load(f)
    
    # List of GROUP BY fields. For string_agg.
    sql_group_list = [
        'chembl_id_lookup.chembl_id',
        'component_sequences.accession',
        'drug_mechanism.mechanism_of_action',
        'drug_mechanism.tid',
        'component_sequences.component_id',
        'component_sequences.description',
        'component_sequences.organism',
        'molecule_dictionary.molregno',
        'drug_mechanism.mec_id',
        'target_components.targcomp_id',
        'drug_indication.drugind_id',
        ]
    
    #sql_group_str = ''
    sql_group_str = 'GROUP BY ' + ', '.join(sql_group_list)
    
    def search(id_type, ids):
        """Search for targets by annotations, returning all database columns.
        
        By returning all columns, we allow the user to decide which columns are
        desired, by means of the Django/DataTables interface.
        
        Do note that the argument style is different than byAnnotations().
        
        Arguments:
        id_type -- String describing type of ID. Must be one of:
                'compound', 'target'
        ids -- Python list of IDs to query
        """
        
        # Adjust query condition based on ID type
        if id_type == 'compound':
            condition = 'chembl_id_lookup.chembl_id = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('chembl_id_lookup.chembl_id')
            #groupByIndex = 'chembl_id_lookup__chembl_id'
        elif id_type == 'target':
            condition = 'component_sequences.accession = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('component_sequences.accession')
            #groupByIndex = 'component_sequences__accession'
        else:
            raise Exception("AnnotationSearch: id_type should be either 'compound' or 'target'")
        
        query = sql.SQL("""SELECT DISTINCT {cols} FROM chembl_id_lookup
                        JOIN molecule_dictionary USING(chembl_id)
                        JOIN drug_mechanism USING(molregno)
                        JOIN target_components USING(tid)
                        JOIN component_sequences USING(component_id)
                        LEFT JOIN drug_indication USING(molregno)
                        WHERE {condition}
                        {group}
                        ORDER BY 1""")\
                .format(cols=sql.SQL(', ').join(sql.SQL("{} AS {}".format(c['sql'], c['id'])) for c in AnnotationSearch.annotation_list),
                        condition=sql.SQL(condition),
                        group=sql.SQL(AnnotationSearch.sql_group_str))
        
        data = runQuery2(query, (ids,))
        data = [ d._asdict() for d in data ]
        #return groupBy(lambda t: t[groupByIndex], data)
        return data

class AnnotationWithMeshSearch:
    """Special class for adding MeSH indication data to annotation search"""
    
    annotation_list = AnnotationSearch.annotation_list.copy()
    annotation_list.append({'id': 'annotation__mesh_indication',
                            'sql': "string_agg(mesh_id||':'||mesh_heading,',')",
                            'name': 'MeSH Indication',
                            'desc': "Aggregated list of MeSH identifiers and heading terms",
                            'visible': False,
                            'url': None,
                            })
    
    def search(id_type, ids):
        annotation_data = AnnotationSearch.search(id_type, ids)
        mesh_ind_data = MeshIndicationSearch.search(id_type, ids)
        
        for a in annotation_data:
            mesh_ind = None
            for m in mesh_ind_data:
                if  a['annotation__chembl_id_lookup__chembl_id'] == m['chembl_id_lookup__chembl_id'] and \
                    a['annotation__component_sequences__accession'] == m['component_sequences__accession'] and \
                    a['annotation__drug_mechanism__mechanism_of_action'] == m['drug_mechanism__mechanism_of_action'] and \
                    a['annotation__drug_mechanism__tid'] == m['drug_mechanism__tid'] and \
                    a['annotation__component_sequences__component_id'] == m['component_sequences__component_id'] and \
                    a['annotation__component_sequences__description'] == m['component_sequences__description'] and \
                    a['annotation__component_sequences__organism'] == m['component_sequences__organism']:
                        mesh_ind = m['mesh_indication']
                        break
            a['annotation__mesh_indication'] = mesh_ind
        
        return annotation_data

class ActivitySearch:
    """Class containing activity search functions and related data"""
    
    with open(os.path.join(settings.PROJECT_DIR, 'targetsearch/activity_list.json')) as f:
        activity_list = json.load(f)
    
    def search(id_type, ids):
        """Search for targets by activity, returning all database columns.
        
        By returning all columns, we allow the user to decide which columns are
        desired, by means of the Django/DataTables interface.
        
        Do note that the argument style is different than byActivity().
        
        Arguments:
        id_type -- String describing type of ID. Must be one of:
                'compound', 'target'
        ids -- Python list of IDs to query
        """
        
        # Adjust query condition based on ID type
        if id_type == 'compound':
            condition = 'chembl_id_lookup.chembl_id = ANY(%s)'
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('chembl_id_lookup.chembl_id')
            #groupByIndex = 'chembl_id_lookup__chembl_id'
        elif id_type == 'target':
            condition = "chembl_id_lookup.entity_type='COMPOUND' AND component_sequences.accession = ANY(%s)"
            #groupByIndex = AnnotationSearch.cols_fqn_list.index('component_sequences.accession')
            #groupByIndex = 'component_sequences__accession'
        else:
            raise Exception("ActivitySearch: id_type should be either 'compound' or 'target'")
        
        query = sql.SQL("""SELECT {cols} FROM chembl_id_lookup
                        JOIN activities ON(entity_id = molregno)
                        JOIN molecule_dictionary USING(molregno)
                        JOIN assays USING(assay_id)
                        JOIN target_components USING(tid)
                        JOIN component_sequences USING(component_id)
                        WHERE {condition}
                        ORDER BY 1""")\
                .format(cols=sql.SQL(', ').join(sql.SQL("{} AS {}".format(c['sql'], c['id'])) for c in ActivitySearch.activity_list),
                        condition=sql.SQL(condition))
        
        data = runQuery2(query, (ids,))
        data = [ d._asdict() for d in data ]
        #return groupBy(lambda t: t[groupByIndex], data)
        return data

def mapToChembl(unknownIds, sourceId):
    chemblIds = set()
    for unknownId in unknownIds:
        req = requests.get("https://www.ebi.ac.uk/unichem/rest/src_compound_id/"+unknownId+"/"+str(sourceId)+"/1")
        #print("\n\nreq.json: "+str(req.json()))
        result = req.json()
        #print("got result: "+str(result))
        if "error" in result: 
            raise Exception(result["error"])
        if isinstance(result,list) and len(result) > 0 and ("src_compound_id" in result[0]) :
            chemblIds.add(result[0]["src_compound_id"])

    #print("final chembl ids: "+str(chemblIds))

    return tuple(chemblIds)

def getUniChemSources():
    sources = {}
    sourceReq = requests.get("https://www.ebi.ac.uk/unichem/rest/src_ids/")
    sourceIds = [ source["src_id"] for source in sourceReq.json()]

    for sourceId in sourceIds:
        infoReq = requests.get(" https://www.ebi.ac.uk/unichem/rest/sources/"+sourceId)
        data = infoReq.json()[0]
        #print(str(data["src_id"])+"\t"+data["name_label"])
        sources[data["src_id"]] = data["name_label"]

    return sources;


#getUniChemSources()
#mapToChembl(['DB00829','DB00945'],2)

#print(chemblTargetAccessionsByActivity(('CHEMBL26',)))
#print(chemblTargetAccessionsByAnnotations(('CHEMBL25',)))
